#!/usr/bin/env bash
#
# Copyright 2019, TAQTIQA LLC
#
# All rights reserved - Do Not Redistribute
#
# Generated by Chef Cookbook developer.chef
# Local modifications will be overridden
#
# NOTE:
# The `exit 0` on error ensures that `git rebase master`, and such
# commands, do not result in a detached HEAD state.
#
# Reference:
#
# * https://github.com/DrVanScott/git-clone-init
# * https://riptutorial.com/git/example/27005/git-pre-push-hook

# Pre-Push hook to trigger local CI/CD before pushing objects

# A better class of script...
if [[ ${DEBUG-} =~ ^1|y|yes|true$ ]]; then
  set -o xtrace       # Trace the execution of the script (debug)
  export verbose=1    # Set verbose mode for verbose_print
fi

set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline

# Set GIT_DIR
export GIT_DIR=${GIT_DIR-$(git rev-parse --git-dir)}
export GIT_REPO_FOLDER="$(dirname "${GIT_DIR}")"

function warn {
  echo "ERROR - pre-push hook: $*"  1>&2
}

# DESC: Handler for unexpected errors
# ARGS: $1 (optional): Exit code (defaults to 1)
# OUTS: None
function script_trap_err() {
    local exit_code=1

    # Disable the error trap handler to prevent potential recursion
    trap - ERR

    # Consider any further errors non-fatal to ensure we run to completion
    set +o errexit
    set +o pipefail

    # Validate any provided exit code
    if [[ ${1-} =~ ^[0-9]+$ ]]; then
        exit_code="$1"
    fi

    # Output debug data if in Cron mode
    if [[ -n ${cron-} ]]; then
        # Restore original file output descriptors
        if [[ -n ${script_output-} ]]; then
            exec 1>&3 2>&4
        fi

        # Print basic debugging information
        printf '%b\n' "$ta_none"
        printf '***** Abnormal termination of script *****\n'
        printf 'Script Path:            %s\n' "$script_path"
        printf 'Script Parameters:      %s\n' "$script_params"
        printf 'Script Exit Code:       %s\n' "$exit_code"

        # Print the script log if we have it. It's possible we may not if we
        # failed before we even called cron_init(). This can happen if bad
        # parameters were passed to the script so we bailed out very early.
        if [[ -n ${script_output-} ]]; then
            printf 'Script Output:\n\n%s' "$(cat "$script_output")"
        else
            printf 'Script Output:          None (failed before log init)\n'
        fi
    fi

    # Exit with failure status
    exit "$exit_code"
}

# DESC: Handler for exiting the script
# ARGS: None
# OUTS: None
function script_trap_exit() {
    cd "$orig_cwd"

    # Remove Cron mode script log
    if [[ -n ${cron-} && -f ${script_output-} ]]; then
        rm "$script_output"
    fi

    # Remove script execution lock
    if [[ -d ${script_lock-} ]]; then
        rmdir "$script_lock"
    fi

    # Restore terminal colours
    printf '%b' "$ta_none"
}

# DESC: Exit script with the given message
# ARGS: $1 (required): Message to print on exit
#       $2 (optional): Exit code (defaults to 0)
# OUTS: None
# NOTE: The convention used in this script for exit codes is:
#       0: Normal exit
#       1: Abnormal exit due to external error
#       2: Abnormal exit due to script error
function script_exit() {
    if [[ $# -eq 1 ]]; then
        printf '%s\n' "$1"
        exit 0
    fi

    if [[ ${2-} =~ ^[0-9]+$ ]]; then
        printf '%b\n' "$1"
        # If we've been provided a non-zero exit code run the error trap
        if [[ $2 -ne 0 ]]; then
            script_trap_err "$2"
        else
            exit 0
        fi
    fi

    script_exit 'Missing required argument to script_exit()!' 2
}

# DESC: Generic script initialisation
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: $orig_cwd: The current working directory when the script was run
#       $script_path: The full path to the script
#       $script_dir: The directory path of the script
#       $script_name: The file name of the script
#       $script_params: The original parameters provided to the script
#       $ta_none: The ANSI control code to reset all text attributes
# NOTE: $script_path only contains the path that was used to call the script
#       and will not resolve any symlinks which may be present in the path.
#       You can use a tool like realpath to obtain the "true" path. The same
#       caveat applies to both the $script_dir and $script_name variables.
# shellcheck disable=SC2034
function script_init() {
  # Useful paths
  readonly orig_cwd="$PWD"
  readonly script_path="${BASH_SOURCE[0]}"
  readonly script_dir="$(dirname "$script_path")"
  readonly script_name="$(basename "$script_path")"
  readonly script_params="$*"

  # Important to always set as we use it in the exit handler
  readonly ta_none="$(tput sgr0 2> /dev/null || true)"
}

# DESC: Validate we have superuser access as root (via sudo if requested)
# ARGS: $1 (optional): Set to any value to not attempt root access via sudo
# OUTS: None
function check_superuser() {
  local superuser
  if [[ $EUID -eq 0 ]]
  then
    superuser=true
  elif [[ -z ${1-} ]]
  then
    if check_binary sudo
    then
      verbose_print 'Sudo: Updating cached credentials ...'
      if ! sudo -v
      then
        verbose_print "Sudo: Couldn't acquire credentials ..." \
            "${fg_red-}"
      else
        local test_euid
        test_euid="$(sudo -H -- "$BASH" -c 'printf "%s" "$EUID"')"
        if [[ $test_euid -eq 0 ]]
        then
            superuser=true
        fi
      fi
    fi
  fi

  if [[ -z ${superuser-} ]]; then
    verbose_print 'Unable to acquire superuser credentials.' "${fg_red-}"
    return 1
  fi

  verbose_print 'Successfully acquired superuser credentials.'
  return 0
}

# DESC: Run the requested command as root (via sudo if requested)
# ARGS: $1 (optional): Set to zero to not attempt execution via sudo
#       $@ (required): Passed through for execution as root user
# OUTS: None
function run_as_root() {
    if [[ $# -eq 0 ]]; then
        script_exit 'Missing required argument to run_as_root()!' 2
    fi

    if [[ ${1-} =~ ^0$ ]]; then
        local skip_sudo=true
        shift
    fi

    if [[ $EUID -eq 0 ]]; then
        "$@"
    elif [[ -z ${skip_sudo-} ]]; then
        sudo -H -- "$@"
    else
        script_exit "Unable to run requested command as root: $*" 1
    fi
}

# DESC: Pretty print the provided string
# ARGS: $1 (required): Message to print (defaults to a green foreground)
#       $2 (optional): Colour to print the message with. This can be an ANSI
#                      escape code or one of the prepopulated colour variables.
#       $3 (optional): Set to any value to not append a new line to the message
# OUTS: None
function pretty_print() {
    if [[ $# -lt 1 ]]; then
      script_exit 'Missing required argument to pretty_print()!' 2
    fi

    if [[ -z ${no_colour-} ]]; then
      if [[ -n ${2-} ]]; then
        printf '%b' "$2"
      else
        printf '%b' "$fg_green"
      fi
    fi

    # Print message & reset text attributes
    if [[ -n ${3-} ]]; then
      printf '%s%b' "$1" "$ta_none"
    else
      printf '%s%b\n' "$1" "$ta_none"
    fi
}

# DESC: Only pretty_print() the provided string if verbose mode is enabled
# ARGS: $@ (required): Passed through to pretty_print() function
# OUTS: None
function verbose_print() {
  if [[ -n ${verbose-} ]]; then
    pretty_print "$@"
  fi
}

# This hook is called with the following parameters:
#
#  $1 -- Name of the remote to which the push is being done (Ex: origin)
#  $2 -- URL to which the push is being done
#        Ex: https://<host>:<port>/<username>/<project_name>.git

script_init

protected_branch='master'
remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
  if [[ "$remote_ref" == *"$protected_branch"* ]]; then
    echo "You're about to push to master, is that what you intended? [y|n]"
    read -n 1 -r < /dev/tty
    echo
    if echo $REPLY | grep -E '^[Yy]$' > /dev/null; then
        exit 0 # push will execute
    fi
    verbose_print "Not pushing to ${}"
    exit 1 # push will not execute
  fi

  if [ "$local_sha" = $z40 ]
  then
    # Handle delete
    :
  else
    if [ "$remote_sha" = $z40 ]
    then
      # New branch, examine only current commits
      range="$local_sha"
    else
      # Update to existing branch, examine new commits
      range="$remote_sha..$local_sha"
    fi

    # Check for WIP in this commit reference e.g. refs/heads/<branch-name>
    commit=$(git rev-list --max-count 1 --grep 'WIP' --regexp-ignore-case --walk-reflogs "$local_ref")
    if [ -n "$commit" ]
    then
      echo "Found WIP statement in commit in $local_ref. Not pushing."
      exit 1
    fi
  fi
done

## Push Repo to Gitea Server in Network Namespace
#
# Network namespace (currently) requires we run a rootful container.
#
# run_as_root /usr/bin/podman run \
#             --rm \
#             --interactive \
#             --tty \
#             --dns 10.200.200.1 \
#             --env=DOMAIN=localhost \
#             --name gitea-pre-push \
#             --network=ns:/var/run/netns/drone \
#             --volume ${GIT_REPO_FOLDER}:/data/gitea/work/drone-repo \
#             --volume /usr/share/gitea/pre-push.sh:/usr/local/bin/gitea-pre-push.sh \
#             yelgeb/gitea:0.9.10 \
#             bash gitea-pre-push.sh
exit 0
